<!DOCTYPE html><html lang="en"><head><meta charSet="utf-8"/><meta http-equiv="X-UA-Compatible" content="IE=edge"/><title>&#x27;Best Practices&#x27; · Twirp</title><meta name="viewport" content="width=device-width"/><meta name="generator" content="Docusaurus"/><meta name="description" content="Twirp simplifies service design when compared with a REST endpoint: method"/><meta name="docsearch:language" content="en"/><meta property="og:title" content="&#x27;Best Practices&#x27; · Twirp"/><meta property="og:type" content="website"/><meta property="og:url" content="https://twitchtv.github.io/twirp/index.html"/><meta property="og:description" content="Twirp simplifies service design when compared with a REST endpoint: method"/><meta name="twitter:card" content="summary"/><link rel="shortcut icon" href="/twirp/undefined"/><link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/tomorrow.min.css"/><script type="text/javascript" src="https://buttons.github.io/buttons.js"></script><script src="/twirp/js/scrollSpy.js"></script><link rel="stylesheet" href="/twirp/css/main.css"/><script src="/twirp/js/codetabs.js"></script></head><body class="sideNavVisible"><div class="fixedHeaderContainer"><div class="headerWrapper wrapper"><header><a href="/twirp/"><h2 class="headerTitle">Twirp</h2></a><div class="navigationWrapper navigationSlider"><nav class="slidingNav"><ul class="nav-site nav-site-internal"><li class=""><a href="/twirp/docs/intro.html" target="_self">Docs</a></li><li class=""><a href="/twirp/docs/spec_v7.html" target="_self">Spec</a></li></ul></nav></div></header></div></div><div class="navPusher"><div class="docMainWrapper wrapper"><div class="container mainContainer docsContainer"><div class="wrapper"><div class="post"><header class="postHeader"><h1 id="__docusaurus" class="postHeaderTitle">&#x27;Best Practices&#x27;</h1></header><article><div><span><p>Twirp simplifies service design when compared with a REST endpoint: method
definitions, message types and parsing is handled by the framework (i.e. you
don’t have to worry about JSON fields or types). However, there are still some
things to consider when making a new service in Twirp, mainly to keep
consistency.</p>
<h2><a class="anchor" aria-hidden="true" id="folderpackage-structure"></a><a href="#folderpackage-structure" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Folder/Package Structure</h2>
<p>The recommended folder/package structure for your twirp <code>&lt;service&gt;</code> is:</p>
<pre><code class="hljs">/cmd
    /<span class="hljs-symbol">&lt;service&gt;</span>
        main.<span class="hljs-keyword">go</span>
/rpc
    /<span class="hljs-symbol">&lt;service&gt;</span>
        service.proto
        // <span class="hljs-built_in">and</span> auto-generated <span class="hljs-keyword">files</span>
/internal
    /<span class="hljs-symbol">&lt;service&gt;</span>server
        server.<span class="hljs-keyword">go</span>
        // <span class="hljs-built_in">and</span> usually one other <span class="hljs-keyword">file</span> per method
</code></pre>
<p>For example, for the Haberdasher service it would be:</p>
<pre><code class="hljs">/cmd
    /haberdasherserver
        main<span class="hljs-selector-class">.go</span>
/rpc
    /haberdasher
        service<span class="hljs-selector-class">.proto</span>
        service<span class="hljs-selector-class">.pb</span><span class="hljs-selector-class">.go</span>
        service<span class="hljs-selector-class">.twirp</span><span class="hljs-selector-class">.go</span>
/internal
    /haberdasherserver
        server_test<span class="hljs-selector-class">.go</span>
        server<span class="hljs-selector-class">.go</span>
        make_hat_test<span class="hljs-selector-class">.go</span>
        make_hat<span class="hljs-selector-class">.go</span>
</code></pre>
<p>Notes:</p>
<ul>
<li>Keep the <code>.proto</code> and generated files in their own package.</li>
<li>Do not implement the server or other files in the same package. This allows
other services to do a &quot;clean import&quot; of the autogenerated client.</li>
<li>Do not name the package something generic like <code>api</code>, <code>client</code> or <code>service</code>;
name it after your service. Remember that the package is going to be imported
by other projects that will likely import other clients from other services
as well.</li>
</ul>
<h2><a class="anchor" aria-hidden="true" id="proto-file"></a><a href="#proto-file" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><code>.proto</code> File</h2>
<p>The <code>.proto</code> file is the source of truth for your service design.</p>
<ul>
<li>The first step to design your service is to write a <code>.proto</code> file. Use that
to discuss design with your coworkers before starting the implementation.</li>
<li>Use proto3 (first line should be <code>syntax=&quot;proto3&quot;</code>). Do not use proto2.</li>
<li>Use <code>option go_package = &quot;&lt;service&gt;&quot;;</code> for the Go package name.</li>
<li>Add comments on message fields; they translate to the generated Go
interfaces.</li>
<li>Don’t worry about fields like <code>user_id</code> being auto-converted into <code>UserId</code> in
Go. I know, the right case should be <code>UserID</code>, but it's not your fault how
the protoc-gen-go compiler decides to translate it. Avoid doing hacks like
naming it <code>user_i_d</code> so it looks &quot;good&quot; in Go (<code>UserID</code>). In the future, we
may use a better Go code generator, or generate clients for other languages
like Python or JavaScript.</li>
<li>rpc methods should clearly be named with <action><resource> (i.e.: ListBooks,
GetBook, CreateBook, UpdateBook, RenameBook, DeleteBook). See more in &quot;Naming
Conventions&quot; below.</li>
</ul>
<p>The header of the <code>.proto</code> file should look like this (change <repo> and
<service> with your values):</p>
<pre><code class="hljs css language-go">syntax = <span class="hljs-string">"proto3"</span>

<span class="hljs-keyword">package</span> &lt;organization&gt;.&lt;repo&gt;.&lt;service&gt;;

option go_package = <span class="hljs-string">"&lt;service&gt;"</span>;
</code></pre>
<h2><a class="anchor" aria-hidden="true" id="specifying-protoc-version-and-using-makefile-for-code-generation"></a><a href="#specifying-protoc-version-and-using-makefile-for-code-generation" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Specifying protoc version and using <code>Makefile</code> for code generation</h2>
<p>Code generation depends on <code>protoc</code> and its plugins <code>protoc-gen-go</code> and
<code>protoc-gen-twirp</code>. Having different versions may cause problems.</p>
<p>Make sure to specify the required <code>protoc</code> version in your README or
CONTRIBUTING file.</p>
<p>Using a Makefile is a good way to simplify code generation:</p>
<pre><code class="hljs css language-Makefile"><span class="hljs-section">gen:</span>
    <span class="hljs-comment"># Auto-generate code</span>
    protoc --proto_path=. --twirp_out=. --go_out=. rpc/&lt;service&gt;/service.proto

<span class="hljs-section">upgrade:</span>
    <span class="hljs-comment"># Upgrade dependencies if using modules</span>
    go get -u
</code></pre>
<h2><a class="anchor" aria-hidden="true" id="naming-conventions"></a><a href="#naming-conventions" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Naming Conventions</h2>
<p>Like in any other API or interface, it is very important to have names that are
simple, intuitive and consistent.</p>
<p>Respect the <a href="https://developers.google.com/protocol-buffers/docs/style">Protocol Buffers Style Guide</a>:</p>
<ul>
<li>Use <code>CamelCase</code> for <code>Service</code>, <code>Message</code> and <code>Type</code> names.</li>
<li>Use <code>underscore_separated_names</code> for field names.</li>
<li>Use <code>CAPITALS_WITH_UNDERSCORES</code> for enum value names.</li>
</ul>
<p>For naming conventions, the
<a href="https://cloud.google.com/apis/design/naming_convention">Google Cloud Platform design guides</a>
are a good reference:</p>
<ul>
<li>Use the same name for the same concept, even across APIs.</li>
<li>Avoid name overloading. Use different names for different concepts.</li>
<li>Include units on field names for durations and quantities (e.g.
<code>delay_seconds</code> is better than just <code>delay</code>).</li>
</ul>
<p>For times, we have a few Twitch-specific conventions that have worked for us:</p>
<ul>
<li>Timestamp names should end with <code>_at</code> whenever possible (i.e. <code>created_at</code>,
<code>updated_at</code>).</li>
<li>Timestamps should be <a href="https://tools.ietf.org/html/rfc3339">RFC3339</a> strings
(in Go it's very easy to generate these with <code>t.Format(time.RFC3339)</code> and
parse them with <code>time.Parse(time.RFC3339Nano, t)</code>).</li>
<li>Timestamps can also be a <code>google.protobuf.Timestamp</code>, in which case their
names should end with <code>_time</code> for clarity.</li>
</ul>
<h2><a class="anchor" aria-hidden="true" id="default-values-and-required-fields"></a><a href="#default-values-and-required-fields" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Default Values and Required Fields</h2>
<p>In proto3 all fields have zero-value defaults (string is <code>&quot;&quot;</code>, int32 is <code>0</code>), so
all fields are optional.</p>
<p>If you want to make a required field (i.e. &quot;name is required&quot;), it needs to be
handled by the service implementation. But to make this clear in the <code>.proto</code>
file:</p>
<ul>
<li>Add a &quot;required&quot; comment on the field. For example <code>string name = 1; // required</code> implies that the server implementation will return an
<code>twirp.RequiredArgumentError(&quot;name&quot;)</code> if the name is empty.</li>
</ul>
<p>If you need a different default (e.g. limit default 20 for paginated
collections), it needs to be handled by the service implementation. But to make
this clear in the <code>.proto</code> file:</p>
<ul>
<li>Add a &quot;(default X)&quot; comment on the field. For example <code>int32 limit = 1; // (default 20)</code> implies that the server implementation will convert the
zero-value 0 to 20 (0 == 20).</li>
<li>For enums, the first item is the default.</li>
</ul>
<p>Your service implementation cannot tell the difference between empty and missing
fields (this is by design). If you really need to tell them apart, you need to
use an extra bool field, or use <code>google/protobuf.wrappers.proto</code> messages (which
can be nil in go).</p>
<h2><a class="anchor" aria-hidden="true" id="twirp-errors"></a><a href="#twirp-errors" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Twirp Errors</h2>
<p>Protocol Buffers do not specify errors. You can always add an extra field on the
returned message for the error, but Twirp has an excellent system that you
should use instead:</p>
<ul>
<li>Familiarize yourself with the possible <a href="/twirp/docs/errors.html">Twirp error codes</a> and use
the ones that make sense for each situation (i.e. <code>InvalidArgument</code>,
<code>NotFound</code>, <code>Internal</code>). The codes are very straightforward and are almost
the same as in gRPC.</li>
<li>Always return a <code>twirp.Error</code>. Twirp allows you to return a regular <code>error</code>,
that will get wrapped with <code>twirp.InternalErrorWith(err)</code>, but it is better
if you explicitly wrap it yourself. Being explicit makes the server and the
client to always return the same twirp errors, which is more predictable and
easier for unit tests.</li>
<li>Include possible errors on the <code>.proto</code> file (add comments to RPC methods).</li>
<li>But there's no need to document all the obvious <code>Internal</code> errors, which can
always happen for diverse reasons (e.g. backend service is down, or there was
a problem on the client).</li>
<li>Make sure to document (with comments) possible validation errors on the
specific message fields. For example <code>int32 amount = 1; // must be positive</code>
implies that the server implementation will return a
<code>twirp.InvalidArgumentError(&quot;amount&quot;, &quot;must be positive&quot;)</code> error if the condition
is not met.</li>
<li>Required fields are also validation errors. For example, if a given string
field cannot be empty, you should add a &quot;required&quot; comment in the proto file,
which implies that a <code>twirp.RequiredArgumentError(field)</code> will be returned if
the field is empty (or missing, which is the same thing in proto3). If you
are using proto2 (I hope not), the &quot;required&quot; comment is still preferred over
the required field type.</li>
</ul>
</span></div></article></div><div class="docs-prevnext"></div></div></div></div><footer class="nav-footer" id="footer"><section class="copyright">Copyright © 2021 Twitch Interactive, Inc.</section></footer></div></body></html>